# Supabase 프로젝트 연동

- https://supabase.com/
- `깃허브`로 회원가입 함.
- `New organization` 으로 프로젝트 생성 (아무것도 없을시 자동으로 생성창으로 넘어감)
- `데이터베이스 비밀번호`는 꼭 보관하자. (.env)
- 테이블 생성 (Table Editor 또는 SQL Editor)
- 기본형은 `Table Editor` 로 생성하고 추가적 설정은 `SQL Editor`
- 익숙하다면 `SQl Editor` 로 관리 권장. (ChatGPT 활용 권장)

## 1. todos 테이블 생성 쿼리

```sql
CREATE TABLE todos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title VARCHAR NOT NULL,
    completed BOOLEAN DEFAULT FALSE NOT NULL,
    content TEXT,
    updated_at TIMESTAMPTZ DEFAULT now(),
    created_at TIMESTAMPTZ DEFAULT now()
);
```

## 2. `.env` 파일 생성

- `VITE_` 를 접두어로 사용

```
VITE_SUPABASE_DB_PW=데이터베이스 비밀번호
VITE_SUPABASE_URL=URL값
VITE_SUPABASE_ANON_KEY=키값
```

- Supabase URL 과 Anon Key 파악하기
  - Project 선택 후 `Project Overview` 에서 확인
  - `Project API` 항목에서 파악 가능

## 3. Supabase 클라이언트 라이브러리 설치

```bash
npm install @supabase/supabase-js
```

## 4. 폴더 및 파일 구조

- `/src/lib 폴더` 생성
- `/src/lib/supabase.ts 파일` 생성

```ts
import { createClient } from '@supabase/supabase-js';

// CRA : process.env... 의 환경변수 호출과는 형식이 다름.
// Vite : import.meta.env... 환경변수 호출

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}
// 웹브라우저 클라이언트 생성
export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

## 5. Supabase 의 테이블의 칼럼의 데이터 타입 정의

### 5.1. 데이터 타입 쉽게 추출하기

```bash
npx supabase login
```

- 향후 지시하는 대로 실행함.
- `id` 는 URL 의 앞쪽 단어가 ID가 됨.
  - id 는 Supabase URL 의 앞단어
  - 또는 메뉴로 진입시 `Project Settings` > `General settings`
- package.json 추가

```json
"generate-types": "npx supabase gen types typescript --project-id 프로젝트아이디 --schema 경로 > 파일명.ts"
```

- `scripts` 에 항목 장석(`npm run generate-types`)

```json
// 이 명령어를 주면 타입을 만들어 준다.
"scripts": {
    ...
    "generate-types": "npx supabase gen types typescript --project-id sbmtgbobratzifhqaeyk --schema public > types_db.ts"
  },
```

```bash
npm run generate-types
```

- `types_db.ts` 이 생성됨. (supabase에서 만든 타입을 가져온 것) 그대로 사용해도 괜찮지만, 관리하고있는 type 폴더안에 넣는 것도 좋다.

- 생성된 ts 의 내용을 참조해서 우리가 원하는 곳에 복사 및 붙여넣기 권장
  - 권장사항 : `/src/types/database.ts 생성 및 붙여넣기`
  - 편하게 활용하기 위한 처리

```ts
export type Todo = Database['public']['Tables']['todos']['Row'];
export type TodoInsert = Database['public']['Tables']['todos']['Insert'];
export type TodoUpdate = Database['public']['Tables']['todos']['Update'];
```

## 6. CRUD 실행해 보기

### 6.1. CRUD 를 위한 폴더 및 파일 구조

- https://supabase.com/docs/reference/javascript/start
- /src/apis 폴더 생성 또는 `/src/services 폴더` 생성
- 예) `/src/services 폴더`로 진행
- `/src/services/todoService.ts` 파일 생성
- 반드시 `async ... await` 활용(비동기)
- 반드시 함수 리턴타입 : `Promise<리턴 데이터타입>`
  - axios, fetch 등등...

```ts
import { supabase } from '../lib/supabase';
import type { Todo, TodoInsert, TodoUpdate } from '../types/TodoType';

// Todo 목록 조회
export const getTodos = async (): Promise<Todo[]> => {
  const { data, error } = await supabase
    .from('todos')
    .select('*')
    .order('created_at', { ascending: false });
  // 실행은 되었지만, 결과가 오류이다.
  if (error) {
    throw new Error(`getTodos 오류 : ${error.message}`);
  }
  return data || [];
};
// Todo 생성
export const createTodos = async (newTodo: TodoInsert): Promise<Todo | null> => {
  try {
    const { data, error } = await supabase
      .from('todos')
      .insert([{ ...newTodo, completed: false }])
      .select()
      .single();
    if (error) {
      throw new Error(`createTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
// Todo 수정
export const updateTodos = async (id: number, editTitle: TodoUpdate): Promise<Todo | null> => {
  try {
    const { data, error } = await supabase
      .from('todos')
      .update({ ...editTitle, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single();
    if (error) {
      throw new Error(`updateTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
// Todo 삭제
export const deleteTodos = async (id: number): Promise<void> => {
  try {
    const { error } = await supabase.from('todos').delete().eq('id', id);
    if (error) {
      throw new Error(`deleteTodos 오류 : ${error.message}`);
    }
  } catch (error) {
    console.log(error);
  }
};
// completed toggle
export const toggleTodo = async (id: number, completed: boolean): Promise<Todo | null> => {
  return updateTodos(id, { completed });
};
```

## 7. todos 예제

- /src/types/ TodoType.ts

```ts
export type TodoType = { id: string; title: string; completed: boolean };
// 개발자가 집적 장서해 줌---
export type Todo = Database['public']['Tables']['todos']['Row'];
export type TodoInsert = Database['public']['Tables']['todos']['Insert'];
export type TodoUpdate = Database['public']['Tables']['todos']['Update'];
// ------ 여기까지
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: '13.0.4';
  };
  public: {
    Tables: {
      todos: {
        Row: {
          completed: boolean;
          content: string | null;
          created_at: string | null;
          id: number;
          title: string;
          updated_at: string | null;
        };
        Insert: {
          completed?: boolean;
          content?: string | null;
          created_at?: string | null;
          id?: number;
          title: string;
          updated_at?: string | null;
        };
        Update: {
          completed?: boolean;
          content?: string | null;
          created_at?: string | null;
          id?: number;
          title?: string;
          updated_at?: string | null;
        };
        Relationships: [];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      [_ in never]: never;
    };
    Enums: {
      [_ in never]: never;
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
};

type DatabaseWithoutInternals = Omit<Database, '__InternalSupabase'>;

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, 'public'>];

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema['Tables'] & DefaultSchema['Views'])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Views'])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Views'])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema['Tables'] & DefaultSchema['Views'])
    ? (DefaultSchema['Tables'] & DefaultSchema['Views'])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema['Enums']
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions['schema']]['Enums']
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions['schema']]['Enums'][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema['Enums']
    ? DefaultSchema['Enums'][DefaultSchemaEnumNameOrOptions]
    : never;

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema['CompositeTypes']
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes']
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes'][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema['CompositeTypes']
    ? DefaultSchema['CompositeTypes'][PublicCompositeTypeNameOrOptions]
    : never;

export const Constants = {
  public: {
    Enums: {},
  },
} as const;
```

- /src/services/todoService.ts

```ts
import { supabase } from '../lib/supabase';
import type { Todo, TodoInsert, TodoUpdate } from '../types/TodoType';

// Todo 목록 조회
export const getTodos = async (): Promise<Todo[]> => {
  const { data, error } = await supabase
    .from('todos')
    .select('*')
    .order('created_at', { ascending: false });
  // 실행은 되었지만, 결과가 오류이다.
  if (error) {
    throw new Error(`getTodos 오류 : ${error.message}`);
  }
  return data || [];
};
// Todo 생성
export const createTodos = async (newTodo: TodoInsert): Promise<Todo | null> => {
  try {
    const { data, error } = await supabase
      .from('todos')
      .insert([{ ...newTodo, completed: false }])
      .select()
      .single();
    if (error) {
      throw new Error(`createTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
// Todo 수정
export const updateTodos = async (id: number, editTitle: TodoUpdate): Promise<Todo | null> => {
  try {
    const { data, error } = await supabase
      .from('todos')
      .update({ ...editTitle, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single();
    if (error) {
      throw new Error(`updateTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
// Todo 삭제
export const deleteTodos = async (id: number): Promise<void> => {
  try {
    const { error } = await supabase.from('todos').delete().eq('id', id);
    if (error) {
      throw new Error(`deleteTodos 오류 : ${error.message}`);
    }
  } catch (error) {
    console.log(error);
  }
};
// completed toggle
export const toggleTodo = async (id: number, completed: boolean): Promise<Todo | null> => {
  return updateTodos(id, { completed });
};
```

- /src/contexts/TodoContext.tsx

```tsx
import React, {
  createContext,
  useContext,
  useEffect,
  useReducer,
  type PropsWithChildren,
} from 'react';
// 전체 DB 가져오기
import { getTodos } from '../services/todoService';
import type { Todo } from '../types/TodoType';

// 1. 초기값
type TodosState = { todos: Todo[] };
const initialState: TodosState = {
  todos: [],
};
// 2. 리듀서
// action 은 {type: "문자열", payload: 재료} 형태
enum TodoActionType {
  ADD = 'ADD',
  DELETE = 'DELETE',
  TOGGLE = 'TOGGLE',
  EDIT = 'EDIT',
  // Supabase todos 의 목록읽기
  SET_TODOS = 'SET_TODOS',
}

type ADDAction = { type: TodoActionType.ADD; payload: { todo: Todo } };
type DELETEAction = { type: TodoActionType.DELETE; payload: { id: number } };
type TOGGLEAction = { type: TodoActionType.TOGGLE; payload: { id: number } };
type EDITAction = { type: TodoActionType.EDIT; payload: { id: number; title: string } };
// supabase 목록으로 state.todos 배열을 채워라.
type SetTodosAction = { type: TodoActionType.SET_TODOS; payload: { todos: Todo[] } };

function reducer(
  state: TodosState,
  action: ADDAction | DELETEAction | TOGGLEAction | EDITAction | SetTodosAction,
) {
  switch (action.type) {
    //  return 외에 다른 함수가 추가적으로 들어갈때 함수{}로 묶어줘야 한다.
    case TodoActionType.ADD: {
      const { todo } = action.payload;
      return { ...state, todos: [todo, ...state.todos] };
    }
    case TodoActionType.TOGGLE: {
      const { id } = action.payload;
      const arr = state.todos.map(item =>
        item.id === id ? { ...item, completed: !item.completed } : item,
      );
      return { ...state, todos: arr };
    }
    case TodoActionType.DELETE: {
      const { id } = action.payload;
      const arr = state.todos.filter(item => item.id !== id);
      return { ...state, todos: arr };
    }
    case TodoActionType.EDIT: {
      const { id, title } = action.payload;
      const arr = state.todos.map(item => (item.id === id ? { ...item, title: title } : item));
      return { ...state, todos: arr };
    }
    // Supabase 에 목록 읽기
    case TodoActionType.SET_TODOS: {
      const { todos } = action.payload;
      return { ...state, todos };
    }
    default:
      return state;
  }
}
// 3. context 생성
// 만들어진 Context 가 관리하는 Value 의 모양
type TodoContextValue = {
  todos: Todo[];
  addTodo: (todo: Todo) => void;
  toggleTodo: (id: number) => void;
  deleteTodo: (id: number) => void;
  editTodo: (id: number, editTitle: string) => void;
};

const TodoContext = createContext<TodoContextValue | null>(null);

// 3. provider 생성

// type TodoProviderProps = {
//   children: React.ReactNode;
// }; 이걸 더 권장함.
export const TodoProvider: React.FC<PropsWithChildren> = ({ children }): JSX.Element => {
  const [state, dispatch] = useReducer(reducer, initialState);
  // dispatch 를 위함 함수 표현식 모음
  const addTodo = (newTodo: Todo) => {
    dispatch({ type: TodoActionType.ADD, payload: { todo: newTodo } });
  };
  const toggleTodo = (id: number) => {
    dispatch({ type: TodoActionType.TOGGLE, payload: { id } });
  };
  const deleteTodo = (id: number) => {
    dispatch({ type: TodoActionType.DELETE, payload: { id } });
  };
  const editTodo = (id: number, editTitle: string) => {
    dispatch({ type: TodoActionType.EDIT, payload: { id, title: editTitle } });
  };
  // 실행시 state {todos} 를 업데이트함.
  // reducer 함수를 실행함.
  const setTodos = (todos: Todo[]) => {
    dispatch({ type: TodoActionType.SET_TODOS, payload: { todos } });
  };
  // Supabase 의 목록 읽기 함수 표현식
  // 비동기 데이터베이스 접근
  const LoadTodos = async (): Promise<void> => {
    try {
      const result = await getTodos();
      setTodos(result);
    } catch (error) {
      console.log(error);
    }
  };
  useEffect(() => {
    LoadTodos();
  }, []);
  // value 전달할 값
  const value: TodoContextValue = {
    todos: state.todos,
    addTodo: addTodo,
    toggleTodo: toggleTodo,
    deleteTodo: deleteTodo,
    editTodo: editTodo,
  };
  return <TodoContext.Provider value={value}>{children}</TodoContext.Provider>;
};
// 3. custom hook 생성
export function useTodos(): TodoContextValue {
  const ctx = useContext(TodoContext);
  if (!ctx) {
    throw new Error('컨텍스트가 없어요.');
  }
  return ctx;
}
```

- /src/lib/supabase.ts

```ts
import { createClient } from '@supabase/supabase-js';

// CRA 의 환경변수 호출과는 형식이 다름.
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
```

- /src/components/todos/TodoList.tsx

```tsx
import { useTodos } from '../../contexts/TodoContext';
import type { Todo } from '../../types/TodoType';
import TodoItem from './TodoItem';

type TodoListProps = {};

const TodoList = ({}: TodoListProps): JSX.Element => {
  const { todos } = useTodos();
  return (
    <div>
      <h2>TodoList</h2>
      <ul>
        {todos.map((item: Todo) => (
          <TodoItem key={item.id} todo={item}></TodoItem>
        ))}
      </ul>
    </div>
  );
};

export default TodoList;
```

- /src/components/todos/TodoItem.tsx

```tsx
import React, { useState } from 'react';
import { useTodos } from '../../contexts/TodoContext';
import {
  deleteTodos as deleteTodoService,
  toggleTodo as toggleTodoService,
  updateTodos as updateTodoService,
} from '../../services/todoService';
import type { Todo } from '../../types/TodoType';

type TodoItemProps = {
  todo: Todo;
};

const TodoItem = ({ todo }: TodoItemProps): JSX.Element => {
  const { toggleTodo, editTodo, deleteTodo } = useTodos();
  // 수정중인지
  const [isEdit, setIsEdit] = useState<boolean>(false);
  const [editTitle, setEditTitle] = useState<string>(todo.title);
  const handleChangeTitle = (e: React.ChangeEvent<HTMLInputElement>): void => {
    setEditTitle(e.target.value);
  };
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>): void => {
    if (e.key === 'Enter') {
      handleEditSave();
    }
  };
  // 비동기로 DB 에 update 한다.
  const handleEditSave = async (): Promise<void> => {
    if (!editTitle.trim()) {
      alert('제목을 입력하세요.');
      return;
    }
    try {
      // DB 의 내용 업데이트
      const result = await updateTodoService(todo.id, { title: editTitle });
      if (result) {
        // context 의 state, todos 의 항목 1개의 타이틀 수정
        editTodo(todo.id, editTitle);
        setIsEdit(false);
      }
    } catch (error) {
      console.log('데이터 업데이트에 실패하였습니다.');
    }

    if (editTitle.trim()) {
      editTodo(todo.id, editTitle);
      // setEditTitle(''); //필요없음
      setIsEdit(false);
    }
  };
  const handleEditCancel = (): void => {
    setEditTitle(todo.title);
    setIsEdit(false);
  };

  // 비동기 통신으로 toggle 업데이트
  const handleToggle = async (): Promise<void> => {
    try {
      // DB 의 completed 가 업데이트 성공시 Todo 타입 리턴
      const result = await toggleTodoService(todo.id, !todo.completed);
      if (result) {
        // context 의 state.todos 의 1개 항목 completed 업데이트
        toggleTodo(todo.id);
      }
    } catch (error) {
      console.log('데이터베이스 Toggle 이 실패하였습니다.');
    }
  };
  // DB 의 데이터 delete
  const handleDelete = async (): Promise<void> => {
    try {
      // db 삭제
      await deleteTodoService(todo.id);
      // state 삭제기능
      deleteTodo(todo.id);
    } catch (error) {
      console.log('DB 삭제에 실패했습니다.', error);
    }
  };

  return (
    <li>
      {isEdit ? (
        <>
          <input
            type="text"
            value={editTitle}
            onChange={e => handleChangeTitle(e)}
            onKeyDown={e => handleKeyDown(e)}
          />
          <button onClick={handleEditSave}>저장</button>
          <button onClick={handleEditCancel}>취소</button>
        </>
      ) : (
        <>
          <input type="checkbox" checked={todo.completed} onChange={handleToggle} />
          <span>{todo.title}</span>
          <button onClick={() => setIsEdit(true)}>수정</button>
          <button onClick={() => handleDelete()}>삭제</button>
        </>
      )}
    </li>
  );
};

export default TodoItem;
```

- /src/components/todos/TodoWrite.tsx

```tsx
import React, { useState } from 'react';
import { useTodos } from '../../contexts/TodoContext';
import type { TodoInsert } from '../../types/TodoType';
import { createTodos } from '../../services/todoService';

type TodoWriteProps = {
  childres?: React.ReactNode;
};

const TodoWrite = ({}: TodoWriteProps): JSX.Element => {
  // Context 를 사용함.
  const { addTodo } = useTodos();

  const [title, setTitle] = useState<string>('');
  const [content, setContent] = useState<string>('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    setTitle(e.target.value);
  };
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>): void => {
    if (e.key === 'Enter') {
      handleSave();
    }
  };

  // Supabase 에 데이터를 Insert 한다. : 비동기
  const handleSave = async (): Promise<void> => {
    if (!title.trim()) {
      alert('제목을 입력하세요.');

      return;
    }
    try {
      const newTodo: TodoInsert = { title: title, content: content };
      // Supabase 에 데이터를 Insert 함.
      // Insert 결과로 추가가 된 Todo 형태를 받아옮.
      const result = await createTodos(newTodo);
      if (result) {
        // comtext 에 Todo 타입 데이터를 추가해 줌.
        addTodo(result);
      }
      // 현재 Write 컴포넌트 state 초기화
      setTitle('');
      setContent('');
    } catch (error) {
      console.log(error);
      alert('데이터 추가에 실패했습니다.');
    }
  };

  return (
    <div>
      <h2>할일 작성</h2>
      <div>
        <input
          type="text"
          value={title}
          onChange={e => handleChange(e)}
          onKeyDown={e => handleKeyDown(e)}
        />
        <button onClick={handleSave}>등록</button>
      </div>
    </div>
  );
};

export default TodoWrite;
```

- /src/App.tsx

```tsx
import TodoList from './components/todos/TodoList';
import TodoWrite from './components/todos/TodoWrite';
import { TodoProvider } from './contexts/TodoContext';

function App() {
  return (
    <div>
      <h1>Todo Service</h1>
      <TodoProvider>
        <TodoWrite />
        <TodoList />
      </TodoProvider>
    </div>
  );
}

export default App;
```
