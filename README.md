# Supabase 인증 연동 Todo 테이블

- `Row Level Security(RLS)`를 적용
- 자신만의 todos 조회, 생성, 수정, 삭제
- 보안을 강화함

## 1. RLS 적용 테이블 만들기

- 기존 todos 테이블 삭제
- 추가 칼럼으로 auth.users의 id (uuid) 를 FK 로 칼럼 설정
- supabase > SQL Editor 활용

```sql
-- todos 테이블 구조
CREATE TABLE todos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    title VARCHAR NOT NULL,
    completed BOOLEAN DEFAULT FALSE NOT NULL,
    content TEXT,
    updated_at TIMESTAMPTZ DEFAULT now(),
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 인덱스 생성
CREATE INDEX idx_todos_user_id ON todos(user_id);
CREATE INDEX idx_todos_created_at ON todos(created_at DESC);

-- RLS 활성화
ALTER TABLE todos ENABLE ROW LEVEL SECURITY;
```

- 설명

```sql
-- todos 테이블 구조
-- todos 테이블 생성
CREATE TABLE todos (
  -- id 칼럼은 PK 이고, 기본을 고유한(IDENTITY) 값으로 자동 증가
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- user_id 는 uuid 로서 auth.users의 id 를 참조하고 사용자 제거시 같이 삭제
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    -- title 칼럼은 비어있으면 안되고, 글자이다.
    title VARCHAR NOT NULL,
    -- complted 는 boolean 으로 기본값이 false 이고 비어있으면 안된다.
    completed BOOLEAN DEFAULT FALSE NOT NULL,
    -- content 는 글자이다. 비어있을 수 있다.
    content TEXT,
    -- 날짜를 현재시간으로 셋팅하라.
    updated_at TIMESTAMPTZ DEFAULT now(),
    created_at TIMESTAMPTZ DEFAULT now()
);

-- 인덱스 생성
-- 빠르게 검색 및 정렬을 위해서 순서를 활성화시켜라.

-- user_id 기준으로 정렬하라.
CREATE INDEX idx_todos_user_id ON todos(user_id);
-- created_at 최신글 기준으로 정렬하라.
CREATE INDEX idx_todos_created_at ON todos(created_at DESC);

-- RLS 활성화
-- todos 테이블은 활성화 RLS로 적용하라.
ALTER TABLE todos ENABLE ROW LEVEL SECURITY;
```

## 2. RLS 적용 후 Policy 정책을 진행해 주어야 함.

- todos 의 보안정책을 작성해서, CRUD 가능하도록 적용.

```sql
-- 사용자는 자신의 todos만 조회 가능
CREATE POLICY "Users can view own todos" ON todos
  FOR SELECT USING (auth.uid() = user_id);

-- 사용자는 자신의 todos만 생성 가능
CREATE POLICY "Users can insert own todos" ON todos
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 사용자는 자신의 todos만 수정 가능
CREATE POLICY "Users can update own todos" ON todos
  FOR UPDATE USING (auth.uid() = user_id);

-- 사용자는 자신의 todos만 삭제 가능
CREATE POLICY "Users can delete own todos" ON todos
  FOR DELETE USING (auth.uid() = user_id);
```

## 3. 칼럼이 변하거나, 테이블이 추가된다면 type 를 생성하자.

```bash
npm run generate-types
```

- /src/types/TodoType.ts

```ts
export type TodoType = { id: string; title: string; completed: boolean };
// 개발자가 집적 장서해 줌---
export type Todo = Database['public']['Tables']['todos']['Row'];
export type TodoInsert = Database['public']['Tables']['todos']['Insert'];
export type TodoUpdate = Database['public']['Tables']['todos']['Update'];
// 사용자 정보 (위험한 행동)
export type profile = Database['public']['Tables']['profiles']['Row'];
export type profileInsert = Database['public']['Tables']['profiles']['Insert'];
export type profileUpdate = Database['public']['Tables']['profiles']['Update'];
// 삭제 신청 목록 정보
export type DeleteRequest = Database['public']['Tables']['account_deletion_requests']['Row'];
export type DeleteRequestInsert =
  Database['public']['Tables']['account_deletion_requests']['Insert'];
export type DeleteRequestUpdate =
  Database['public']['Tables']['account_deletion_requests']['Update'];

// ------ 여기까지

export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: '13.0.4';
  };
  public: {
    Tables: {
      account_deletion_requests: {
        Row: {
          admin_notes: string | null;
          id: string;
          processed_at: string | null;
          processed_by: string | null;
          reason: string | null;
          requested_at: string | null;
          status: string | null;
          user_email: string;
          user_id: string | null;
        };
        Insert: {
          admin_notes?: string | null;
          id?: string;
          processed_at?: string | null;
          processed_by?: string | null;
          reason?: string | null;
          requested_at?: string | null;
          status?: string | null;
          user_email: string;
          user_id?: string | null;
        };
        Update: {
          admin_notes?: string | null;
          id?: string;
          processed_at?: string | null;
          processed_by?: string | null;
          reason?: string | null;
          requested_at?: string | null;
          status?: string | null;
          user_email?: string;
          user_id?: string | null;
        };
        Relationships: [];
      };
      memos: {
        Row: {
          created_at: string;
          id: number;
          memo: string;
        };
        Insert: {
          created_at?: string;
          id?: number;
          memo: string;
        };
        Update: {
          created_at?: string;
          id?: number;
          memo?: string;
        };
        Relationships: [];
      };
      profiles: {
        Row: {
          avatar_url: string | null;
          created_at: string | null;
          id: string;
          nickname: string | null;
        };
        Insert: {
          avatar_url?: string | null;
          created_at?: string | null;
          id: string;
          nickname?: string | null;
        };
        Update: {
          avatar_url?: string | null;
          created_at?: string | null;
          id?: string;
          nickname?: string | null;
        };
        Relationships: [];
      };
      todos: {
        Row: {
          completed: boolean;
          content: string | null;
          created_at: string | null;
          id: number;
          title: string;
          updated_at: string | null;
          user_id: string;
        };
        Insert: {
          completed?: boolean;
          content?: string | null;
          created_at?: string | null;
          id?: number;
          title: string;
          updated_at?: string | null;
          user_id: string;
        };
        Update: {
          completed?: boolean;
          content?: string | null;
          created_at?: string | null;
          id?: number;
          title?: string;
          updated_at?: string | null;
          user_id?: string;
        };
        Relationships: [];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      [_ in never]: never;
    };
    Enums: {
      [_ in never]: never;
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
};

type DatabaseWithoutInternals = Omit<Database, '__InternalSupabase'>;

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, 'public'>];

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema['Tables'] & DefaultSchema['Views'])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Views'])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Views'])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema['Tables'] & DefaultSchema['Views'])
    ? (DefaultSchema['Tables'] & DefaultSchema['Views'])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema['Tables']
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables']
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions['schema']]['Tables'][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema['Tables']
    ? DefaultSchema['Tables'][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema['Enums']
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions['schema']]['Enums']
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions['schema']]['Enums'][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema['Enums']
    ? DefaultSchema['Enums'][DefaultSchemaEnumNameOrOptions]
    : never;

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema['CompositeTypes']
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes']
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions['schema']]['CompositeTypes'][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema['CompositeTypes']
    ? DefaultSchema['CompositeTypes'][PublicCompositeTypeNameOrOptions]
    : never;

export const Constants = {
  public: {
    Enums: {},
  },
} as const;
```

## 4. todoService.ts 일부 타입 수정

- Create 부분

```ts
// Todo 생성
// 로그인을 하고 나면 실제로 user_id 가 이미 파악이 됨.
// TodoInsert 에서 user_id : 값을 생략하는 타입을 생성
// 타입스크립트에서 Omit 을 이용하면, 특정 키를 제거할 수 있음.
export const createTodos = async (newTodo: Omit<TodoInsert, 'user_id'>): Promise<Todo | null> => {
  try {
    // 현재 로그인 한 사용자 정보 가져오기
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      throw new Error('로그인이 필요합니다.');
    }
    const { data, error } = await supabase
      .from('todos')
      .insert([{ ...newTodo, completed: false, user_id: user.id }])
      .select()
      .single();
    if (error) {
      throw new Error(`createTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
```

- Update 부분

```ts
// Todo 수정
// 로그인을 하고 나면 실제로 user_id 가 이미 파악이 됨.
// TodoUpdate 에서 user_id : 값을 생략하는 타입을 생성
// 타입스크립트에서 Omit 을 이용하면, 특정 키를 제거할 수 있음.
export const updateTodos = async (
  id: number,
  editTitle: Omit<TodoUpdate, 'user_id'>,
): Promise<Todo | null> => {
  try {
    const { data, error } = await supabase
      .from('todos')
      .update({ ...editTitle, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single();
    if (error) {
      throw new Error(`updateTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
```

## 5. 알아두기

- RLS 를 적용시 자동으로 필터링이 됨.

```ts
const { data } = await supabase.from('todos').select('*');
// RLS 가 적용이 되었으므로, 자동 필터링 적용됨.
// 실제 실행은 아래 구문으로 실행됨.
// LELECT * FROM todos WHERE auth.uid() = user_id
```

## 6. 최종 todoService.ts 코드

```ts
import { supabase } from '../lib/supabase';
import type { Todo, TodoInsert, TodoUpdate } from '../types/TodoType';

// Todo 목록 조회
export const getTodos = async (): Promise<Todo[]> => {
  const { data, error } = await supabase
    .from('todos')
    .select('*')
    .order('created_at', { ascending: false });
  // 실행은 되었지만, 결과가 오류이다.
  if (error) {
    throw new Error(`getTodos 오류 : ${error.message}`);
  }
  return data || [];
};
// Todo 생성
// 로그인을 하고 나면 실제로 user_id 가 이미 파악이 됨.
// TodoInsert 에서 user_id : 값을 생략하는 타입을 생성
// 타입스크립트에서 Omit 을 이용하면, 특정 키를 제거할 수 있음.
export const createTodos = async (newTodo: Omit<TodoInsert, 'user_id'>): Promise<Todo | null> => {
  try {
    // 현재 로그인 한 사용자 정보 가져오기
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      throw new Error('로그인이 필요합니다.');
    }
    const { data, error } = await supabase
      .from('todos')
      .insert([{ ...newTodo, completed: false, user_id: user.id }])
      .select()
      .single();
    if (error) {
      throw new Error(`createTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
// Todo 수정
// 로그인을 하고 나면 실제로 user_id 가 이미 파악이 됨.
// TodoUpdate 에서 user_id : 값을 생략하는 타입을 생성
// 타입스크립트에서 Omit 을 이용하면, 특정 키를 제거할 수 있음.
export const updateTodos = async (
  id: number,
  editTitle: Omit<TodoUpdate, 'user_id'>,
): Promise<Todo | null> => {
  try {
    const { data, error } = await supabase
      .from('todos')
      .update({ ...editTitle, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single();
    if (error) {
      throw new Error(`updateTodos 오류 : ${error.message}`);
    }
    return data;
  } catch (error) {
    console.log(error);
    return null;
  }
};
// Todo 삭제
export const deleteTodos = async (id: number): Promise<void> => {
  try {
    const { error } = await supabase.from('todos').delete().eq('id', id);
    if (error) {
      throw new Error(`deleteTodos 오류 : ${error.message}`);
    }
  } catch (error) {
    console.log(error);
  }
};
// completed toggle
export const toggleTodo = async (id: number, completed: boolean): Promise<Todo | null> => {
  return updateTodos(id, { completed });
};
```
